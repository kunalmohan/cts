{"version":3,"sources":["../../src/framework/generate_minimal_query_list.ts"],"names":["Logger","makeFilter","treeFromFilterResults","makeQuerySplitterTree","caselist","expectationStrings","expectations","e","filter","id","idIfSingle","Error","push","line","seen","convertToQuerySplitterTree","tree","name","children","needsSplit","undefined","moreThanOneFile","definitelyOneFile","matchingExpectations","map","matches","some","m","queryNode","Map","k","v","subtree","set","log","values","queryTree","generateMinimalQueryList","unsplitNodes","findUnsplitNodes","node","exp"],"mappings":"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","sourcesContent":["import { TestSpecOrTestOrCaseID } from './id.js';\nimport { Logger } from './logger.js';\nimport { TestFilterResult, makeFilter } from './test_filter/index.js';\nimport { FilterResultTreeNode, treeFromFilterResults } from './tree.js';\n\ninterface QuerySplitterTreeNode {\n  needsSplit: boolean;\n  children?: Map<string, QuerySplitterTreeNode>;\n}\n\ninterface Expectation {\n  id: TestSpecOrTestOrCaseID;\n  line: string;\n  seen: boolean;\n}\n\nfunction makeQuerySplitterTree(\n  caselist: TestFilterResult[],\n  expectationStrings: string[]\n): QuerySplitterTreeNode {\n  const expectations: Expectation[] = [];\n  for (const e of expectationStrings) {\n    const filter = makeFilter(e);\n    const id = filter.idIfSingle();\n    if (!id) {\n      throw new Error(\n        'Can only handle expectations which cover one file, one test, or one case. ' + e\n      );\n    }\n    expectations.push({ id, line: e, seen: false });\n  }\n\n  const convertToQuerySplitterTree = (\n    tree: FilterResultTreeNode,\n    name?: string\n  ): QuerySplitterTreeNode => {\n    const children = tree.children;\n    let needsSplit = true;\n\n    if (name !== undefined) {\n      const filter = makeFilter(name);\n      const moreThanOneFile = !filter.definitelyOneFile();\n      const matchingExpectations = expectations.map(e => {\n        const matches = filter.matches(e.id);\n        if (matches) e.seen = true;\n        return matches;\n      });\n      needsSplit = matchingExpectations.some(m => m) || moreThanOneFile;\n    }\n\n    const queryNode: QuerySplitterTreeNode = { needsSplit };\n    if (children) {\n      queryNode.children = new Map();\n      for (const [k, v] of children) {\n        const subtree = convertToQuerySplitterTree(v, k);\n        queryNode.children.set(k, subtree);\n      }\n    }\n    return queryNode;\n  };\n\n  const log = new Logger();\n  const tree = treeFromFilterResults(log, caselist.values());\n  const queryTree = convertToQuerySplitterTree(tree)!;\n\n  for (const e of expectations) {\n    if (!e.seen) throw new Error('expectation had no effect: ' + e.line);\n  }\n\n  return queryTree;\n}\n\n// Takes a TestFilterResultIterator enumerating every test case in the suite, and a list of\n// expectation queries from a browser's expectations file. Creates a minimal list of queries\n// (i.e. wpt variant lines) such that:\n//\n// - There is at least one query per spec file.\n// - Each of those those input queries is in the output, so that it can have its own expectation.\n//\n// It does this by creating a tree from the list of cases (same tree as the standalone runner uses),\n// then marking every node which is a parent of a node that matches an expectation.\nexport async function generateMinimalQueryList(\n  caselist: TestFilterResult[],\n  expectationStrings: string[]\n): Promise<string[]> {\n  const unsplitNodes: string[] = [];\n  const findUnsplitNodes = (name: string, node: QuerySplitterTreeNode | undefined) => {\n    if (node === undefined) {\n      return;\n    }\n    if (node.needsSplit && node.children) {\n      for (const [k, v] of node.children) {\n        findUnsplitNodes(k, v);\n      }\n    } else {\n      unsplitNodes.push(name);\n    }\n  };\n\n  const queryTree = makeQuerySplitterTree(caselist, expectationStrings);\n  findUnsplitNodes('', queryTree);\n\n  for (const exp of expectationStrings) {\n    if (!unsplitNodes.some(name => name === exp)) {\n      throw new Error(\n        'Something went wrong: all expectation strings should always appear exactly: ' + exp\n      );\n    }\n  }\n  return unsplitNodes;\n}\n"],"file":"generate_minimal_query_list.js"}
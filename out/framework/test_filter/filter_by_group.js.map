{"version":3,"sources":["../../../src/framework/test_filter/filter_by_group.ts"],"names":["FilterByGroup","constructor","suite","groupPrefix","specPathPrefix","matches","id","spec","pathMatches","path","iterate","loader","specs","listing","entries","description","isReadme","endsWith","import","push","definitelyOneFile","idIfSingle","undefined","startsWith"],"mappings":";;;;;;AAMA,OAAO,MAAMA,aAAN,CAA0C;AAI/CC,EAAAA,WAAW,CAACC,KAAD,EAAgBC,WAAhB,EAAqC;AAAA;;AAAA;;AAC9C,SAAKD,KAAL,GAAaA,KAAb;AACA,SAAKE,cAAL,GAAsBD,WAAtB;AACD;;AAEDE,EAAAA,OAAO,CAACC,EAAD,EAAsC;AAC3C,WAAOA,EAAE,CAACC,IAAH,CAAQL,KAAR,KAAkB,KAAKA,KAAvB,IAAgC,KAAKM,WAAL,CAAiBF,EAAE,CAACC,IAAH,CAAQE,IAAzB,CAAvC;AACD;;AAED,QAAMC,OAAN,CAAcC,MAAd,EAAmE;AACjE,UAAMC,KAAK,GAAG,MAAMD,MAAM,CAACE,OAAP,CAAe,KAAKX,KAApB,CAApB;AACA,UAAMY,OAA2B,GAAG,EAApC;AAEA,UAAMZ,KAAK,GAAG,KAAKA,KAAnB;;AACA,SAAK,MAAM;AAAEO,MAAAA,IAAF;AAAQM,MAAAA;AAAR,KAAX,IAAoCH,KAApC,EAA2C;AACzC,UAAI,KAAKJ,WAAL,CAAiBC,IAAjB,CAAJ,EAA4B;AAC1B,cAAMO,QAAQ,GAAGP,IAAI,KAAK,EAAT,IAAeA,IAAI,CAACQ,QAAL,CAAc,GAAd,CAAhC;AACA,cAAMV,IAAI,GAAGS,QAAQ,GAChB;AAAED,UAAAA;AAAF,SADgB,GAEf,MAAMJ,MAAM,CAACO,MAAP,CAAe,GAAEhB,KAAM,IAAGO,IAAK,UAA/B,CAFZ;AAGAK,QAAAA,OAAO,CAACK,IAAR,CAAa;AAAEb,UAAAA,EAAE,EAAE;AAAEJ,YAAAA,KAAF;AAASO,YAAAA;AAAT,WAAN;AAAuBF,UAAAA;AAAvB,SAAb;AACD;AACF;;AAED,WAAOO,OAAP;AACD;;AAEDM,EAAAA,iBAAiB,GAAY;AAC3B;AACA;AACA,WAAO,KAAP;AACD;;AAEDC,EAAAA,UAAU,GAAc;AACtB;AACA,WAAOC,SAAP;AACD;;AAEOd,EAAAA,WAAR,CAAoBC,IAApB,EAA2C;AACzC,WAAOA,IAAI,CAACc,UAAL,CAAgB,KAAKnB,cAArB,CAAP;AACD;;AA5C8C","sourcesContent":["import { TestSpecOrTestOrCaseID } from '../id.js';\nimport { ReadmeFile, TestFileLoader, TestSpec } from '../loader.js';\n\nimport { TestFilterResult } from './index.js';\nimport { TestFilter } from './internal.js';\n\nexport class FilterByGroup implements TestFilter {\n  private readonly suite: string;\n  private readonly specPathPrefix: string;\n\n  constructor(suite: string, groupPrefix: string) {\n    this.suite = suite;\n    this.specPathPrefix = groupPrefix;\n  }\n\n  matches(id: TestSpecOrTestOrCaseID): boolean {\n    return id.spec.suite === this.suite && this.pathMatches(id.spec.path);\n  }\n\n  async iterate(loader: TestFileLoader): Promise<TestFilterResult[]> {\n    const specs = await loader.listing(this.suite);\n    const entries: TestFilterResult[] = [];\n\n    const suite = this.suite;\n    for (const { path, description } of specs) {\n      if (this.pathMatches(path)) {\n        const isReadme = path === '' || path.endsWith('/');\n        const spec = isReadme\n          ? ({ description } as ReadmeFile)\n          : ((await loader.import(`${suite}/${path}.spec.js`)) as TestSpec);\n        entries.push({ id: { suite, path }, spec });\n      }\n    }\n\n    return entries;\n  }\n\n  definitelyOneFile(): boolean {\n    // FilterByGroup could always possibly match multiple files, because it represents a prefix,\n    // e.g. \"a:b\" not \"a:b:\".\n    return false;\n  }\n\n  idIfSingle(): undefined {\n    // FilterByGroup could be one whole suite, but we only want whole files, tests, or cases.\n    return undefined;\n  }\n\n  private pathMatches(path: string): boolean {\n    return path.startsWith(this.specPathPrefix);\n  }\n}\n"],"file":"filter_by_group.js"}
{"version":3,"sources":["../../../src/framework/test_filter/load_filter.ts"],"names":["allowedTestNameCharacters","assert","unreachable","FilterByGroup","FilterByParamsExact","FilterByParamsMatch","FilterByTestMatch","makeFilter","filter","i1","indexOf","suite","substring","i2","groupPrefix","path","endOfTestName","RegExp","i3sub","search","testPrefix","i3","test","token","charAt","params","length","JSON","parse","loadFilter","loader","iterate"],"mappings":";;;;AAAA,SAASA,yBAAT,QAA0C,0BAA1C;AAGA,SAASC,MAAT,EAAiBC,WAAjB,QAAoC,kBAApC;AAEA,SAASC,aAAT,QAA8B,sBAA9B;AACA,SAASC,mBAAT,EAA8BC,mBAA9B,EAAmDC,iBAAnD,QAA4E,sBAA5E;AAIA;AACA,OAAO,SAASC,UAAT,CAAoBC,MAApB,EAAgD;AACrD,QAAMC,EAAE,GAAGD,MAAM,CAACE,OAAP,CAAe,GAAf,CAAX;AACAT,EAAAA,MAAM,CAACQ,EAAE,KAAK,CAAC,CAAT,EAAY,gEAAZ,CAAN;AAEA,QAAME,KAAK,GAAGH,MAAM,CAACI,SAAP,CAAiB,CAAjB,EAAoBH,EAApB,CAAd;AACA,QAAMI,EAAE,GAAGL,MAAM,CAACE,OAAP,CAAe,GAAf,EAAoBD,EAAE,GAAG,CAAzB,CAAX;;AACA,MAAII,EAAE,KAAK,CAAC,CAAZ,EAAe;AACb;AACA;AACA;AACA;AACA,UAAMC,WAAW,GAAGN,MAAM,CAACI,SAAP,CAAiBH,EAAE,GAAG,CAAtB,CAApB;AACA,WAAO,IAAIN,aAAJ,CAAkBQ,KAAlB,EAAyBG,WAAzB,CAAP;AACD;;AAED,QAAMC,IAAI,GAAGP,MAAM,CAACI,SAAP,CAAiBH,EAAE,GAAG,CAAtB,EAAyBI,EAAzB,CAAb;AACA,QAAMG,aAAa,GAAG,IAAIC,MAAJ,CAAW,OAAOjB,yBAAP,GAAmC,GAA9C,CAAtB;AACA,QAAMkB,KAAK,GAAGV,MAAM,CAACI,SAAP,CAAiBC,EAAE,GAAG,CAAtB,EAAyBM,MAAzB,CAAgCH,aAAhC,CAAd;;AACA,MAAIE,KAAK,KAAK,CAAC,CAAf,EAAkB;AAChB;AACA;AACA,UAAME,UAAU,GAAGZ,MAAM,CAACI,SAAP,CAAiBC,EAAE,GAAG,CAAtB,CAAnB;AACA,WAAO,IAAIP,iBAAJ,CAAsB;AAAEK,MAAAA,KAAF;AAASI,MAAAA;AAAT,KAAtB,EAAuCK,UAAvC,CAAP;AACD;;AAED,QAAMC,EAAE,GAAGR,EAAE,GAAG,CAAL,GAASK,KAApB;AACA,QAAMI,IAAI,GAAGd,MAAM,CAACI,SAAP,CAAiBC,EAAE,GAAG,CAAtB,EAAyBQ,EAAzB,CAAb;AACA,QAAME,KAAK,GAAGf,MAAM,CAACgB,MAAP,CAAcH,EAAd,CAAd;AAEA,MAAII,MAAM,GAAG,IAAb;;AACA,MAAIJ,EAAE,GAAG,CAAL,GAASb,MAAM,CAACkB,MAApB,EAA4B;AAC1BD,IAAAA,MAAM,GAAGE,IAAI,CAACC,KAAL,CAAWpB,MAAM,CAACI,SAAP,CAAiBS,EAAE,GAAG,CAAtB,CAAX,CAAT;AACD;;AAED,MAAIE,KAAK,KAAK,GAAd,EAAmB;AACjB;AACA;AACA;AACA,WAAO,IAAIlB,mBAAJ,CAAwB;AAAEM,MAAAA,KAAF;AAASI,MAAAA;AAAT,KAAxB,EAAyCO,IAAzC,EAA+CG,MAA/C,CAAP;AACD,GALD,MAKO,IAAIF,KAAK,KAAK,GAAd,EAAmB;AACxB;AACA;AACA;AACA,WAAO,IAAInB,mBAAJ,CAAwB;AAAEO,MAAAA,KAAF;AAASI,MAAAA;AAAT,KAAxB,EAAyCO,IAAzC,EAA+CG,MAA/C,CAAP;AACD,GALM,MAKA;AACLvB,IAAAA,WAAW,CAAC,uDAAD,CAAX;AACD;AACF;AAED,OAAO,SAAS2B,UAAT,CAAoBC,MAApB,EAA4CtB,MAA5C,EAAyF;AAC9F,SAAOD,UAAU,CAACC,MAAD,CAAV,CAAmBuB,OAAnB,CAA2BD,MAA3B,CAAP;AACD","sourcesContent":["import { allowedTestNameCharacters } from '../allowed_characters.js';\nimport { TestFileLoader } from '../loader.js';\nimport { ParamSpec } from '../params/index.js';\nimport { assert, unreachable } from '../util/index.js';\n\nimport { FilterByGroup } from './filter_by_group.js';\nimport { FilterByParamsExact, FilterByParamsMatch, FilterByTestMatch } from './filter_one_file.js';\nimport { TestFilterResult } from './index.js';\nimport { TestFilter } from './internal.js';\n\n// Each filter is of one of the forms below (urlencoded).\nexport function makeFilter(filter: string): TestFilter {\n  const i1 = filter.indexOf(':');\n  assert(i1 !== -1, 'Test queries must fully specify their suite name (e.g. \"cts:\")');\n\n  const suite = filter.substring(0, i1);\n  const i2 = filter.indexOf(':', i1 + 1);\n  if (i2 === -1) {\n    // - cts:\n    // - cts:buf\n    // - cts:buffers/\n    // - cts:buffers/map\n    const groupPrefix = filter.substring(i1 + 1);\n    return new FilterByGroup(suite, groupPrefix);\n  }\n\n  const path = filter.substring(i1 + 1, i2);\n  const endOfTestName = new RegExp('[^' + allowedTestNameCharacters + ']');\n  const i3sub = filter.substring(i2 + 1).search(endOfTestName);\n  if (i3sub === -1) {\n    // - cts:buffers/mapWriteAsync:\n    // - cts:buffers/mapWriteAsync:b\n    const testPrefix = filter.substring(i2 + 1);\n    return new FilterByTestMatch({ suite, path }, testPrefix);\n  }\n\n  const i3 = i2 + 1 + i3sub;\n  const test = filter.substring(i2 + 1, i3);\n  const token = filter.charAt(i3);\n\n  let params = null;\n  if (i3 + 1 < filter.length) {\n    params = JSON.parse(filter.substring(i3 + 1)) as ParamSpec;\n  }\n\n  if (token === '~') {\n    // - cts:buffers/mapWriteAsync:basic~\n    // - cts:buffers/mapWriteAsync:basic~{}\n    // - cts:buffers/mapWriteAsync:basic~{filter:\"params\"}\n    return new FilterByParamsMatch({ suite, path }, test, params);\n  } else if (token === '=') {\n    // - cts:buffers/mapWriteAsync:basic=\n    // - cts:buffers/mapWriteAsync:basic={}\n    // - cts:buffers/mapWriteAsync:basic={exact:\"params\"}\n    return new FilterByParamsExact({ suite, path }, test, params);\n  } else {\n    unreachable(\"invalid character after test name; must be '~' or '='\");\n  }\n}\n\nexport function loadFilter(loader: TestFileLoader, filter: string): Promise<TestFilterResult[]> {\n  return makeFilter(filter).iterate(loader);\n}\n"],"file":"load_filter.js"}
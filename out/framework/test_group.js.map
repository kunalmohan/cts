{"version":3,"sources":["../../src/framework/test_group.ts"],"names":["allowedTestNameCharacters","extractPublicParams","paramsEquals","checkPublicParamType","assert","validNames","RegExp","TestGroup","constructor","fixture","Set","iterate","log","test","tests","checkName","name","decodeURIComponent","seen","has","add","fn","indexOf","replace","Test","push","params","specs","cases","Array","from","spec","publicParams","v","Object","values","some","x","rec","RunCaseSpecific","recorder","id","run","debug","res","record","start","inst","init","finalize","ex","threw","finish","injectResult","result","assign"],"mappings":"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","sourcesContent":["import { allowedTestNameCharacters } from './allowed_characters.js';\nimport { Fixture } from './fixture.js';\nimport { TestCaseID } from './id.js';\nimport { LiveTestCaseResult, TestCaseRecorder, TestSpecRecorder } from './logger.js';\nimport { ParamSpec, ParamSpecIterable, extractPublicParams, paramsEquals } from './params/index.js';\nimport { checkPublicParamType } from './url_query.js';\nimport { assert } from './util/index.js';\n\nexport interface RunCase {\n  readonly id: TestCaseID;\n  run(debug?: boolean): Promise<LiveTestCaseResult>;\n  injectResult(result: LiveTestCaseResult): void;\n}\n\nexport interface RunCaseIterable {\n  iterate(rec: TestSpecRecorder): Iterable<RunCase>;\n}\n\ntype FixtureClass<F extends Fixture> = new (log: TestCaseRecorder, params: ParamSpec) => F;\ntype TestFn<F extends Fixture> = (t: F) => Promise<void> | void;\n\nconst validNames = new RegExp('^[' + allowedTestNameCharacters + ']+$');\n\nexport class TestGroup<F extends Fixture> implements RunCaseIterable {\n  private fixture: FixtureClass<F>;\n  private seen: Set<string> = new Set();\n  private tests: Array<Test<F>> = [];\n\n  constructor(fixture: FixtureClass<F>) {\n    this.fixture = fixture;\n  }\n\n  *iterate(log: TestSpecRecorder): Iterable<RunCase> {\n    for (const test of this.tests) {\n      yield* test.iterate(log);\n    }\n  }\n\n  private checkName(name: string): void {\n    assert(validNames.test(name), `Invalid test name ${name}; must match [${validNames}]+`);\n    assert(\n      // Shouldn't happen due to the rule above. Just makes sure that treated\n      // unencoded strings as encoded strings is OK.\n      name === decodeURIComponent(name),\n      `Not decodeURIComponent-idempotent: ${name} !== ${decodeURIComponent(name)}`\n    );\n    assert(!this.seen.has(name), `Duplicate test name: ${name}`);\n\n    this.seen.add(name);\n  }\n\n  // TODO: This could take a fixture, too, to override the one for the group.\n  test(name: string, fn: TestFn<F>): Test<F> {\n    // Replace spaces with underscores for readability.\n    assert(name.indexOf('_') === -1, 'Invalid test name ${name}: contains underscore (use space)');\n    name = name.replace(/ /g, '_');\n\n    this.checkName(name);\n\n    const test = new Test<F>(name, this.fixture, fn);\n    this.tests.push(test);\n    return test;\n  }\n}\n\n// This test is created when it's inserted, but may be parameterized afterward (.params()).\nclass Test<F extends Fixture> {\n  readonly name: string;\n  readonly fixture: FixtureClass<F>;\n  readonly fn: TestFn<F>;\n  private cases: ParamSpecIterable | null = null;\n\n  constructor(name: string, fixture: FixtureClass<F>, fn: TestFn<F>) {\n    this.name = name;\n    this.fixture = fixture;\n    this.fn = fn;\n  }\n\n  params(specs: ParamSpecIterable): void {\n    assert(this.cases === null, 'test case is already parameterized');\n    const cases = Array.from(specs);\n    const seen: ParamSpec[] = [];\n    // This is n^2.\n    for (const spec of cases) {\n      const publicParams = extractPublicParams(spec);\n\n      // Check type of public params: can only be (currently):\n      // number, string, boolean, undefined, number[]\n      for (const v of Object.values(publicParams)) {\n        checkPublicParamType(v);\n      }\n\n      assert(!seen.some(x => paramsEquals(x, publicParams)), 'Duplicate test case params');\n      seen.push(publicParams);\n    }\n    this.cases = cases;\n  }\n\n  *iterate(rec: TestSpecRecorder): IterableIterator<RunCase> {\n    for (const params of this.cases || [null]) {\n      yield new RunCaseSpecific(rec, this.name, params, this.fixture, this.fn);\n    }\n  }\n}\n\nclass RunCaseSpecific<F extends Fixture> implements RunCase {\n  readonly id: TestCaseID;\n  private readonly params: ParamSpec | null;\n  private readonly recorder: TestSpecRecorder;\n  private readonly fixture: FixtureClass<F>;\n  private readonly fn: TestFn<F>;\n\n  constructor(\n    recorder: TestSpecRecorder,\n    test: string,\n    params: ParamSpec | null,\n    fixture: FixtureClass<F>,\n    fn: TestFn<F>\n  ) {\n    this.id = { test, params: params ? extractPublicParams(params) : null };\n    this.params = params;\n    this.recorder = recorder;\n    this.fixture = fixture;\n    this.fn = fn;\n  }\n\n  async run(debug: boolean): Promise<LiveTestCaseResult> {\n    const [rec, res] = this.recorder.record(this.id.test, this.id.params);\n    rec.start(debug);\n\n    try {\n      const inst = new this.fixture(rec, this.params || {});\n\n      try {\n        await inst.init();\n        await this.fn(inst);\n      } finally {\n        // Runs as long as constructor succeeded, even if initialization or the test failed.\n        await inst.finalize();\n      }\n    } catch (ex) {\n      // There was an exception from constructor, init, test, or finalize.\n      // An error from init or test may have been a SkipTestCase.\n      // An error from finalize may have been an eventualAsyncExpectation failure.\n      rec.threw(ex);\n    }\n\n    rec.finish();\n    return res;\n  }\n\n  injectResult(result: LiveTestCaseResult): void {\n    const [, res] = this.recorder.record(this.id.test, this.id.params);\n    Object.assign(res, result);\n  }\n}\n"],"file":"test_group.js"}
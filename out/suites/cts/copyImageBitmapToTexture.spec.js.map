{"version":3,"sources":["../../../src/suites/cts/copyImageBitmapToTexture.spec.ts"],"names":["description","TestGroup","pcombine","poptions","GPUTest","calculateRowPitch","width","bytesPerPixel","bytesPerRow","F","checkCopyImageBitmapResult","src","expected","height","exp","Uint8Array","buffer","byteOffset","byteLength","rowPitch","dst","createCopyForMapRead","eventualAsyncExpectation","niceStack","actual","mapReadAsync","check","checkBufferWithRowPitch","undefined","message","rec","fail","destroy","lines","failedPixels","i","j","indexExp","indexActual","push","join","g","test","t","params","imagePixels","Uint8ClampedArray","imageData","ImageData","imageBitmap","createImageBitmap","device","createTexture","size","depth","format","usage","GPUTextureUsage","COPY_DST","COPY_SRC","defaultQueue","copyImageBitmapToTexture","origin","x","y","texture","rowPitchValue","testBuffer","createBuffer","GPUBufferUsage","encoder","createCommandEncoder","copyTextureToBuffer","mipLevel","z","imageHeight","submit","finish"],"mappings":"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","sourcesContent":["export const description = `\ncopy imageBitmap To texture tests.\n`;\n\nimport { TestGroup, pcombine, poptions } from '../../framework/index.js';\n\nimport { GPUTest } from './gpu_test.js';\n\nfunction calculateRowPitch(width: number, bytesPerPixel: number): number {\n  const bytesPerRow = width * bytesPerPixel;\n  // Rounds up to a multiple of 256 according to WebGPU requirements.\n  return (((bytesPerRow - 1) >> 8) + 1) << 8;\n}\n\nclass F extends GPUTest {\n  checkCopyImageBitmapResult(\n    src: GPUBuffer,\n    expected: ArrayBufferView,\n    width: number,\n    height: number,\n    bytesPerPixel: number\n  ): void {\n    const exp = new Uint8Array(expected.buffer, expected.byteOffset, expected.byteLength);\n    const rowPitch = calculateRowPitch(width, bytesPerPixel);\n    const dst = this.createCopyForMapRead(src, rowPitch * height);\n\n    this.eventualAsyncExpectation(async niceStack => {\n      const actual = new Uint8Array(await dst.mapReadAsync());\n      const check = this.checkBufferWithRowPitch(\n        actual,\n        exp,\n        width,\n        height,\n        rowPitch,\n        bytesPerPixel\n      );\n      if (check !== undefined) {\n        niceStack.message = check;\n        this.rec.fail(niceStack);\n      }\n      dst.destroy();\n    });\n  }\n\n  checkBufferWithRowPitch(\n    actual: Uint8Array,\n    exp: Uint8Array,\n    width: number,\n    height: number,\n    rowPitch: number,\n    bytesPerPixel: number\n  ): string | undefined {\n    const lines = [];\n    let failedPixels = 0;\n    for (let i = 0; i < height; ++i) {\n      const bytesPerRow = width * bytesPerPixel;\n      for (let j = 0; j < bytesPerRow; ++j) {\n        const indexExp = j + i * bytesPerRow;\n        const indexActual = j + rowPitch * i;\n        if (actual[indexActual] !== exp[indexExp]) {\n          if (failedPixels > 4) {\n            break;\n          }\n          failedPixels++;\n          lines.push(`at [${indexExp}], expected ${exp[indexExp]}, got ${actual[indexActual]}`);\n        }\n      }\n      if (failedPixels > 4) {\n        lines.push('... and more');\n        break;\n      }\n    }\n    return failedPixels > 0 ? lines.join('\\n') : undefined;\n  }\n}\n\nexport const g = new TestGroup(F);\n\ng.test('from ImageData', async t => {\n  const { width, height } = t.params;\n\n  // The texture format is rgba8uint, so the bytes per pixel is 4.\n  const bytesPerPixel = 4;\n\n  const imagePixels = new Uint8ClampedArray(bytesPerPixel * width * height);\n  for (let i = 0; i < width * height * bytesPerPixel; ++i) {\n    imagePixels[i] = i % 4 === 3 ? 255 : i % 256;\n  }\n\n  const imageData = new ImageData(imagePixels, width, height);\n  const imageBitmap = await createImageBitmap(imageData);\n\n  const dst = t.device.createTexture({\n    size: {\n      width: imageBitmap.width,\n      height: imageBitmap.height,\n      depth: 1,\n    },\n    format: 'rgba8uint',\n    usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,\n  });\n\n  t.device.defaultQueue.copyImageBitmapToTexture(\n    {\n      imageBitmap,\n      origin: {\n        x: 0,\n        y: 0,\n      },\n    },\n    {\n      texture: dst,\n    },\n    {\n      width: imageBitmap.width,\n      height: imageBitmap.height,\n      depth: 1,\n    }\n  );\n\n  const rowPitchValue = calculateRowPitch(imageBitmap.width, bytesPerPixel);\n  const testBuffer = t.device.createBuffer({\n    size: rowPitchValue * imageBitmap.height,\n    usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n  });\n\n  const encoder = t.device.createCommandEncoder();\n\n  encoder.copyTextureToBuffer(\n    { texture: dst, mipLevel: 0, origin: { x: 0, y: 0, z: 0 } },\n    { buffer: testBuffer, rowPitch: rowPitchValue, imageHeight: 0 },\n    { width: imageBitmap.width, height: imageBitmap.height, depth: 1 }\n  );\n  t.device.defaultQueue.submit([encoder.finish()]);\n\n  t.checkCopyImageBitmapResult(\n    testBuffer,\n    imagePixels,\n    imageBitmap.width,\n    imageBitmap.height,\n    bytesPerPixel\n  );\n}).params(\n  pcombine(\n    poptions('width', [1, 2, 4, 15, 255, 256]), //\n    poptions('height', [1, 2, 4, 15, 255, 256])\n  )\n);\n"],"file":"copyImageBitmapToTexture.spec.js"}
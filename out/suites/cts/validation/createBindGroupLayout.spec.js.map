{"version":3,"sources":["../../../../src/suites/cts/validation/createBindGroupLayout.spec.ts"],"names":["description","C","TestGroup","poptions","kBindingTypeInfo","kBindingTypes","kMaxBindingsPerBindGroup","kPerStageBindingLimits","kShaderStages","ValidationTest","clone","descriptor","JSON","parse","stringify","g","test","t","goodDescriptor","bindings","binding","visibility","GPUShaderStage","COMPUTE","type","BindingType","StorageBuffer","device","createBindGroupLayout","badDescriptor","expectValidationError","maxDynamicBufferCount","params","maxDynamicBufferBindings","i","push","hasDynamicOffset","length","UniformBuffer","success","FRAGMENT","kCasesForMaxResourcesPerStageTests","pickExtraBindingTypes","extraTypeSame","maxedType","maxedVisibility","validStages","extraType","extraVisibility","maxedCount","perStageLimitType","maxResourceBindings","newDescriptor","shouldError","goodLayout","createPipelineLayout","bindGroupLayouts","extraLayout","newBindingCountsTowardSamePerStageLimit","layoutExceedsPerStageLimit"],"mappings":"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","sourcesContent":["export const description = `\ncreateBindGroupLayout validation tests.\n`;\n\nimport { C, TestGroup, poptions } from '../../../framework/index.js';\nimport { ParamSpec } from '../../../framework/params/index.js';\nimport {\n  kBindingTypeInfo,\n  kBindingTypes,\n  kMaxBindingsPerBindGroup,\n  kPerStageBindingLimits,\n  kShaderStages,\n} from '../capability_info.js';\n\nimport { ValidationTest } from './validation_test.js';\n\nfunction clone<T extends GPUBindGroupLayoutDescriptor>(descriptor: T): T {\n  return JSON.parse(JSON.stringify(descriptor));\n}\n\nexport const g = new TestGroup(ValidationTest);\n\ng.test('some binding index was specified more than once', async t => {\n  const goodDescriptor = {\n    bindings: [\n      { binding: 0, visibility: GPUShaderStage.COMPUTE, type: C.BindingType.StorageBuffer },\n      { binding: 1, visibility: GPUShaderStage.COMPUTE, type: C.BindingType.StorageBuffer },\n    ],\n  };\n\n  // Control case\n  t.device.createBindGroupLayout(goodDescriptor);\n\n  const badDescriptor = clone(goodDescriptor);\n  badDescriptor.bindings[1].binding = 0;\n\n  // Binding index 0 can't be specified twice.\n  t.expectValidationError(() => {\n    t.device.createBindGroupLayout(badDescriptor);\n  });\n});\n\ng.test('Visibility of bindings can be 0', async t => {\n  t.device.createBindGroupLayout({\n    bindings: [{ binding: 0, visibility: 0, type: 'storage-buffer' }],\n  });\n});\n\ng.test('number of dynamic buffers exceeds the maximum value', async t => {\n  const { type, maxDynamicBufferCount } = t.params;\n\n  const maxDynamicBufferBindings: GPUBindGroupLayoutBinding[] = [];\n  for (let i = 0; i < maxDynamicBufferCount; i++) {\n    maxDynamicBufferBindings.push({\n      binding: i,\n      visibility: GPUShaderStage.COMPUTE,\n      type,\n      hasDynamicOffset: true,\n    });\n  }\n\n  const goodDescriptor = {\n    bindings: [\n      ...maxDynamicBufferBindings,\n      {\n        binding: maxDynamicBufferBindings.length,\n        visibility: GPUShaderStage.COMPUTE,\n        type,\n        hasDynamicOffset: false,\n      },\n    ],\n  };\n\n  // Control case\n  t.device.createBindGroupLayout(goodDescriptor);\n\n  // Dynamic buffers exceed maximum in a bind group layout.\n  const badDescriptor = clone(goodDescriptor);\n  badDescriptor.bindings[maxDynamicBufferCount].hasDynamicOffset = true;\n\n  t.expectValidationError(() => {\n    t.device.createBindGroupLayout(badDescriptor);\n  });\n}).params([\n  { type: C.BindingType.StorageBuffer, maxDynamicBufferCount: 4 },\n  { type: C.BindingType.UniformBuffer, maxDynamicBufferCount: 8 },\n]);\n\ng.test('dynamic set to true is allowed only for buffers', async t => {\n  const type: GPUBindingType = t.params.type;\n  const success = kBindingTypeInfo[type].type === 'buffer';\n\n  const descriptor = {\n    bindings: [{ binding: 0, visibility: GPUShaderStage.FRAGMENT, type, hasDynamicOffset: true }],\n  };\n\n  t.expectValidationError(() => {\n    t.device.createBindGroupLayout(descriptor);\n  }, !success);\n}).params(poptions('type', kBindingTypes));\n\nlet kCasesForMaxResourcesPerStageTests: ParamSpec[];\n{\n  // One bind group layout will be filled with kPerStageBindingLimit[...] of the type |type|.\n  // For each item in the array returned here, a case will be generated which tests a pipeline\n  // layout with one extra bind group layout with one extra binding. That extra binding will have:\n  //\n  //   - If extraTypeSame, any of the binding types which counts toward the same limit as |type|.\n  //     (i.e. 'storage-buffer' <-> 'readonly-storage-buffer').\n  //   - Otherwise, an arbitrary other type.\n  function pickExtraBindingTypes(type: GPUBindingType, extraTypeSame: boolean): GPUBindingType[] {\n    if (extraTypeSame) {\n      switch (type) {\n        case 'storage-buffer':\n        case 'readonly-storage-buffer':\n          return ['storage-buffer', 'readonly-storage-buffer'];\n        default:\n          return [type];\n      }\n    } else {\n      return type === 'sampler' ? ['sampled-texture'] : ['sampler'];\n    }\n  }\n\n  kCasesForMaxResourcesPerStageTests = [];\n  for (const maxedType of kBindingTypes) {\n    for (const maxedVisibility of kShaderStages) {\n      // Don't generate a case where maxedType isn't valid in maxedVisibility.\n      if (!(kBindingTypeInfo[maxedType].validStages & maxedVisibility)) continue;\n\n      for (const extraTypeSame of [true, false]) {\n        for (const extraType of pickExtraBindingTypes(maxedType, extraTypeSame)) {\n          for (const extraVisibility of kShaderStages) {\n            // Don't generate a case where extraType isn't valid in extraVisibility.\n            if (!(kBindingTypeInfo[extraType].validStages & extraVisibility)) continue;\n\n            kCasesForMaxResourcesPerStageTests.push({\n              maxedType,\n              maxedVisibility,\n              extraType,\n              extraVisibility,\n            });\n          }\n        }\n      }\n    }\n  }\n}\n\n// Should never fail unless kMaxBindingsPerBindGroup is exceeded, because the validation for\n// resources-of-type-per-stage is in pipeline layout creation.\ng.test('max resources per stage/in bind group layout', async t => {\n  const maxedType: GPUBindingType = t.params.maxedType;\n  const extraType: GPUBindingType = t.params.extraType;\n  const { maxedVisibility, extraVisibility } = t.params;\n  const maxedCount = kPerStageBindingLimits[kBindingTypeInfo[maxedType].perStageLimitType];\n\n  const maxResourceBindings: GPUBindGroupLayoutBinding[] = [];\n  for (let i = 0; i < maxedCount; i++) {\n    maxResourceBindings.push({\n      binding: i,\n      visibility: maxedVisibility,\n      type: maxedType,\n    });\n  }\n\n  const goodDescriptor = { bindings: maxResourceBindings };\n\n  // Control\n  t.device.createBindGroupLayout(goodDescriptor);\n\n  const newDescriptor = clone(goodDescriptor);\n  newDescriptor.bindings.push({\n    binding: maxedCount,\n    visibility: extraVisibility,\n    type: extraType,\n  });\n\n  const shouldError = maxedCount >= kMaxBindingsPerBindGroup;\n\n  t.expectValidationError(() => {\n    t.device.createBindGroupLayout(newDescriptor);\n  }, shouldError);\n}).params(kCasesForMaxResourcesPerStageTests);\n\n// One pipeline layout can have a maximum number of each type of binding *per stage* (which is\n// different for each type). Test that the max works, then add one more binding of same-or-different\n// type and same-or-different visibility.\ng.test('max resources per stage/in pipeline layout', async t => {\n  const maxedType: GPUBindingType = t.params.maxedType;\n  const extraType: GPUBindingType = t.params.extraType;\n  const { maxedVisibility, extraVisibility } = t.params;\n  const maxedCount = kPerStageBindingLimits[kBindingTypeInfo[maxedType].perStageLimitType];\n\n  const maxResourceBindings: GPUBindGroupLayoutBinding[] = [];\n  for (let i = 0; i < maxedCount; i++) {\n    maxResourceBindings.push({\n      binding: i,\n      visibility: maxedVisibility,\n      type: maxedType,\n    });\n  }\n\n  const goodLayout = t.device.createBindGroupLayout({ bindings: maxResourceBindings });\n\n  // Control\n  t.device.createPipelineLayout({ bindGroupLayouts: [goodLayout] });\n\n  const extraLayout = t.device.createBindGroupLayout({\n    bindings: [{ binding: 0, visibility: extraVisibility, type: extraType }],\n  });\n\n  // Some binding types use the same limit, e.g. 'storage-buffer' and 'readonly-storage-buffer'.\n  const newBindingCountsTowardSamePerStageLimit =\n    (maxedVisibility & extraVisibility) !== 0 &&\n    kBindingTypeInfo[maxedType].perStageLimitType === kBindingTypeInfo[extraType].perStageLimitType;\n  const layoutExceedsPerStageLimit = newBindingCountsTowardSamePerStageLimit;\n\n  t.expectValidationError(() => {\n    t.device.createPipelineLayout({ bindGroupLayouts: [goodLayout, extraLayout] });\n  }, layoutExceedsPerStageLimit);\n}).params(kCasesForMaxResourcesPerStageTests);\n"],"file":"createBindGroupLayout.spec.js"}